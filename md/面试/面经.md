# 知识点

## CSS

### css预加载

### 布局方式

### 定位

### em/rem/px/rpx/vh/vw

### flex/grid

## HTML

## JS

### promise

#### promise原理

#### promise实现

#### 执行顺序

- https://www.jianshu.com/p/910e22a3ba18

### setTimeout

- 最短时间间隔不得低于4ms，老版本为10ms
- 对于dom变动，重新渲染的部分通常不会立即执行，每16ms执行一次
- requestAnimationFrame的效果好于setTimeout


- setTimeout只是将事件插入了“任务队列“，必须等到当前代码（执行栈内部的同步代码）的执行结束，主线程才会去执行它的回调函数，因此如果当前代码执行时间很长，setTimeout的回调函数就得继续等待，所以是无法保证准时执行的

### event loop

- 事件循环
首先是脚本，然后是微任务，渲染等

![event-loop](./imgs/event-loop.png) 

- 每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作

- 微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成

首先会执行栈中的代码，同步任务，就是全局的同步代码，其他的点击事件，以及ajax请求、setTimeout等等异步任务将会进入任务队列中等待，当执行栈的任务执行完毕之后，会从任务队列中按照先进先出的原则执行。当一个宏任务执行完毕之后，会清空所有的微任务，然后再读取下一个宏任务，反复如此。

- 点击事件会先被加入任务队列？异步任务在其后？
- 异步队列存放宏任务和微任务吗？
- 微任务是有别的队列吗？
- 只有同步任务和异步任务，异步任务是指不进入主线程，而进入任务队列的任务，那异步的宏任务和微任务在队列中怎么排列的？以怎样顺序加入任务队列的？

js是一个单线程的，异步和多线程的实现是通过event loop事件循环机制来实现的。首先是从全局的同步代码一行一行的压入执行栈中执行，当遇到setTimeout等属于宏任务的异步代码时，将其添加到消息队列（Message Queue）中；当遇到promise等微任务的异步代码时，将其添加到微任务队列（Microtask Queue）中；执行完执行栈中的同步代码之后，会先清空Microtask Queue内的代码，然后再从Message Queue中读取一个事件执行


#### 宏任务

- setInterval
- setTimeout


#### 微任务

- new Promise
- new MutaionObserver

#### 一些相关文章
- https://zh.javascript.info/event-loop


### 函数柯里化

### 防抖
- 函数防抖
  - 就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间
  - 简单点说就是在一段时间内只执行最后一次
    - 🌰 坐公交，司机需要等最后一个人进入才能关门。每次进入一个人，司机就会多等待几秒再关门
  - 解决某些频繁执行的事件，比如点击事件，滚动事件等等

- 应用场景
  - 搜索框搜索输入，只需要用户最后一次输入完再发送请求
  - 手机号、邮箱格式的输入验证检测
  - 窗口大小的 resize ，只需窗口调整完成后，计算窗口的大小，防止重复渲染

```js
function debounce(callback, delay) {
  let timer = null
  return () => {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(callback, delay)
  }
}
```

```js
/**
 * 优化代码
 *    1. 修改通过debounce处理后的函数的this指向为调用时所处的环境的this
 *    2. 传递参数
*/
function debounce(callback, delay) {
  let timer = null
  // 修改为function声明形式，否则this指向debounce内部this
  return function () {
    // 保存实际调用返回函数时传递的参数
    const arg = arguments
    // 保存this
    const _this = this
    if (timer) {
      clearTimeout(timer)
    }
    // 使用apply改变this指向为 callback 实际调用的环境，传递参数
    timer = setTimeout(() => callback.apply(_this, arg), delay)
  }
}

// 使用
const fn = debounce(function (xx) {
  console.log(xx, this);
}, 1000)
btn.onclick = function () {
  // 需要使用call改变this指向，否则此时是在window下直接调用的
  fn.call(this, 'xxx')
}
```

- 优化
  - 由于箭头函数没有this和arguments，因此可以简略一些代码

```js
function debounce(callback, delay) {
  let timer = null
  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      callback.apply(this, arguments)
    }, delay)
  }
}
```

### 节流

- 函数节流
  - 限制一个函数在一定时间内只能执行一次
    - 🌰 过地铁/火车闸机时，每个人进入后3秒后门关闭，等待下一个人进入

- 应用场景
  - 滚动加载，加载更多或滚动到底部监听
  - 谷歌搜索框，搜索联想功能
  - 高频点击提交，表单重复提交
  - 省市信息对应字母快速选择

```js
function throttle(callback, delay){
  let timer = timer

  return function () {
    if(timer) {
      return 
    }
    timer = setTimeout(()=>{
      callback()
      timer = null
    }, delay)
  }
}
```

```js
// 优化this指向和传参

function throttle(callback, delay){
  let timer = timer

  return function () {
    const args = arguments
    const _this = this
    if(timer) {
      return 
    }
    timer = setTimeout(()=>{
      callback.apply(this, args)
      timer = null
    }, delay)
  }
}
```


### 防抖和节流对比

- 共同点
  - 都是一段时间内只执行一次函数
- 不同点
  - 防抖在一段时间内只执行最后一次，一但此事件被连续执行，会清除之前开启的定时器，重新开启新的定时器
  - 节流在一段时间内只执行第一次，当事件被连续执行时，只有第一次进入函数是会开启定时器，之后一段时间内判断定时器已开启，就会直接return，直到第一次执行完毕，清除了定时器id才会重新执行
  - 因此，防抖和节流的效果对比，当连续点击btn执行函数时，防抖是只有在停止点击之后一段时间之后执行函数；而节流在连续点击时是以设置的delay时间为间隔，连续执行函数，停止点击后执行完最后一段时间内的一次函数则不在执行




### 深拷贝/浅拷贝

#### 浅拷贝

- =
- {...object}
- Object.assign(target, ...sources)


#### 深拷贝

- 代码最少，性能最差，有缺陷
  - 只有能正确处理 Number, String, Boolean, Array, 扁平对象，RegExp对象无法拷贝（拷贝成空对象{}），function也不行，直接拷贝不了这个属性

```js
function deepCopy(obj){
  return JSON.parse(JSON.stringify(obj))
}
```

- 简洁版，for in性能略差

```js
function deepCopy(obj){
  const newObj = Array.isArray(obj) ? [] : {}
  if(typeof(obj) !== 'object') {
    return obj
  }
  for(let key in obj) {
    newObj[key] = deepCopy(obj[key])
  }
  return newObj
}
```

### call/apply

- call和apply

### 实现setInterval

```js
function mySetInterval(callback, delay){
  setTimeout(()=>{
    callback()
    mySetInterval(callback, delay)
  }, delay)
}
```


### 原型链

#### prototype

- 属性为什么要挂载的原型链上

### 继承


### super


## ts

### keyof

### typeof


## VUE

### VUE2

#### nextTick

- 实现原理



### VUE3

#### 新特性

### VUE2/VUE3对比

### MVVM

### SPA/MPA

## React

## 算法

###